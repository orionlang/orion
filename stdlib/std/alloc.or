import std.mem

// Allocator interface
// All allocators must implement this class
// Note: Actual implementations may have additional parameters or return types
// depending on their specific semantics (e.g., returning updated state)

class Allocator {
  alloc: fn(Self, u64) ptr;
  free: fn(Self, ptr) ();
  realloc: fn(Self, ptr, u64) bool;
  remap: fn(Self, ptr, u64) ptr;
}

// System calls for memory management
extern "C" {
  fn mmap(addr: ptr, length: u64, prot: i32, flags: i32, fd: i32, offset: i64) ptr;
  fn munmap(addr: ptr, length: u64) i32;
}

// mmap constants
// PROT flags
// var PROT_READ: i32 = 1
// var PROT_WRITE: i32 = 2
// MAP flags
// var MAP_PRIVATE: i32 = 2
// var MAP_ANONYMOUS: i32 = 32

// Page allocator - allocates memory in page-sized chunks using mmap
// Each allocation is independent and can be freed with munmap
type PageAllocator = {
  page_size: u64,  // Standard page size (4096)
}

instance Allocator[PageAllocator] {
  alloc = fn(self: PageAllocator, num_pages: u64) ptr {
    unsafe {
      var pa: PageAllocator = self

      // Calculate total size to allocate
      var total_size: u64 = num_pages * pa.page_size

      // mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
      // Use @int_to_ptr to create NULL pointer
      var null_addr: u64 = 0
      var addr: ptr = @int_to_ptr(null_addr)
      var prot: i32 = 3  // PROT_READ | PROT_WRITE
      var flags: i32 = 34  // MAP_PRIVATE | MAP_ANONYMOUS
      var fd: i32 = -1
      var offset: i64 = 0

      var ptr: ptr = mmap(addr, total_size, prot, flags, fd, offset)
      return ptr
    }
  }

  free = fn(self: PageAllocator, ptr: ptr, num_pages: u64) () {
    unsafe {
      var pa: PageAllocator = self
      var total_size: u64 = num_pages * pa.page_size
      var result: i32 = munmap(ptr, total_size)
      return ()
    }
  }

  realloc = fn(self: PageAllocator, ptr: ptr, new_size: u64) bool {
    // PageAllocator doesn't support in-place realloc
    return false
  }

  remap = fn(self: PageAllocator, ptr: ptr, old_pages: u64, new_pages: u64) ptr {
    unsafe {
      let pa: PageAllocator = self
      // Allocate new mapping
      let new_ptr: ptr = pa.alloc(new_pages)
      // Copy old data to new_ptr
      let old_size: u64 = old_pages * pa.page_size
      memcpy(new_ptr, ptr, old_size)
      // Free old mapping
      pa.free(ptr, old_pages)
      return new_ptr
    }
  }
}

// Arena allocator - bump allocator, all freed at once
// Uses a PageAllocator as backing allocator
type Arena = {
  parent: PageAllocator,  // Backing allocator
  buffer: ptr,
  capacity: u64,
  used: u64,
  allocated_pages: u64,  // Number of pages allocated for buffer
}

instance Allocator[Arena] {
  alloc = fn(self: Arena, size: u64) (ptr, Arena) {
    unsafe {
      var arena: Arena = self

      // Check if we need to grow the arena
      var new_used: u64 = arena.used + size
      var needs_grow: bool = new_used > arena.capacity

      // Handle arena growth
      var arena_updated: Arena = arena
      if needs_grow {
        // Allocate more pages from parent
        // Calculate how many pages we need for new total capacity
        let page_size: u64 = arena.parent.page_size
        let total_pages_needed: u64 = (new_used + page_size - 1) / page_size  // Round up

        // Allocate from parent
        let new_buffer: ptr = arena.parent.alloc(total_pages_needed)
        let new_capacity: u64 = total_pages_needed * page_size

        // Copy old data to new buffer if we had data
        let has_old_data: bool = arena.used > 0
        if has_old_data {
          let copy_result: () = memcpy(new_buffer, arena.buffer, arena.used)
          // Free old buffer
          let free_result: () = arena.parent.free(arena.buffer, arena.allocated_pages)
        }

        let new_arena: Arena = Arena {
          parent: arena.parent,
          buffer: new_buffer,
          capacity: new_capacity,
          used: arena.used,
          allocated_pages: total_pages_needed,
        }
        arena_updated = new_arena
      }

      // Allocate from arena
      var alloc_ptr: ptr = @ptr_offset(arena_updated.buffer, arena_updated.used)

      // Return updated arena with incremented used counter
      var final_arena: Arena = Arena {
        parent: arena_updated.parent,
        buffer: arena_updated.buffer,
        capacity: arena_updated.capacity,
        used: new_used,
        allocated_pages: arena_updated.allocated_pages,
      }

      return (alloc_ptr, final_arena)
    }
  }

  free = fn(self: Arena, ptr: ptr) () {
    // Arena doesn't free individual allocations
    return ()
  }

  realloc = fn(self: Arena, ptr: ptr, new_size: u64) bool {
    // Arena doesn't support in-place realloc
    return false
  }

  remap = fn(self: Arena, old_ptr: ptr, new_size: u64) ptr {
    // Arena can't remap
    unsafe {
      var arena: Arena = self
      return arena.buffer
    }
  }
}

// General purpose allocator - maintains free list
// Uses first-fit allocation strategy with simple free list
// Block layout: [size: u64][next: ptr][user data...]
type FreeBlock = {
  size: u64,
  next: ptr,
}

type GeneralPurposeAllocator = {
  parent: PageAllocator,  // Backing page allocator
  free_list: ptr,   // Head of free list (null if empty)
  heap_start: ptr,  // Start of heap
  heap_end: ptr,    // Current end of heap
}

instance Allocator[GeneralPurposeAllocator] {
  alloc = fn(self: GeneralPurposeAllocator, size: u64) (ptr, GeneralPurposeAllocator) {
    unsafe {
      var gpa: GeneralPurposeAllocator = self
      var header_size: u64 = 16  // Size of FreeBlock header
      var total_size: u64 = size + header_size

      // Search free list for first-fit block
      let null_addr: u64 = 0
      let null_ptr: ptr = @int_to_ptr(null_addr)
      var current: ptr = gpa.free_list
      var prev: ptr = null_ptr

      // Walk free list looking for a block large enough
      var found_block: ptr = null_ptr
      var found_prev: ptr = null_ptr

      // Linear search through entire free list
      while current != null_ptr {
        let block_size: u64 = @ptr_read(current, @type(u64))
        let fits: bool = block_size >= total_size

        if fits {
          found_block = current
          found_prev = prev
          current = null_ptr  // Break out of loop
        } else {
          let current_next_offset: ptr = @ptr_offset(current, 8)
          let next: ptr = @ptr_read(current_next_offset, @type(ptr))
          prev = current
          current = next
        }
      }

      // If found a free block, use it
      let allocated_ptr: ptr = if found_block != null_ptr {
        // Remove from free list
        let next_offset2: ptr = @ptr_offset(found_block, 8)
        let next_block: ptr = @ptr_read(next_offset2, @type(ptr))

        let new_free_list: ptr = if found_prev == null_ptr {
          // Removing head of list
          next_block
        } else {
          // Removing from middle
          let prev_next_offset: ptr = @ptr_offset(found_prev, 8)
          let _w3: () = @ptr_write(prev_next_offset, next_block)
          gpa.free_list
        }

        let updated_gpa: GeneralPurposeAllocator = GeneralPurposeAllocator {
          parent: gpa.parent,
          free_list: new_free_list,
          heap_start: gpa.heap_start,
          heap_end: gpa.heap_end,
        }
        gpa = updated_gpa

        @ptr_offset(found_block, header_size)
      } else {
        // No free block found, allocate from parent
        // Calculate how many pages we need
        let page_size: u64 = gpa.parent.page_size
        let pages_needed: u64 = (total_size + page_size - 1) / page_size  // Round up

        let new_block: ptr = gpa.parent.alloc(pages_needed)

        // Write block header
        let _w1: () = @ptr_write(new_block, total_size)
        let new_block_next_offset: ptr = @ptr_offset(new_block, 8)
        let _w2: () = @ptr_write(new_block_next_offset, null_ptr)

        @ptr_offset(new_block, header_size)
      }

      let final_gpa: GeneralPurposeAllocator = gpa
      return (allocated_ptr, final_gpa)
    }
  }

  free = fn(self: GeneralPurposeAllocator, ptr: ptr) GeneralPurposeAllocator {
    unsafe {
      var gpa: GeneralPurposeAllocator = self
      var header_size: u64 = 16

      // Get block header by going backwards from user pointer
      // Convert ptr to int, subtract header size, convert back to ptr
      var ptr_as_int: u64 = @ptr_to_int(ptr)
      var header_size_as_int: u64 = 16
      var block_start_int: u64 = ptr_as_int - header_size_as_int
      var block_start: ptr = @int_to_ptr(block_start_int)

      // Read current free list head
      var old_head: ptr = gpa.free_list

      // Write old head as next pointer for this block
      var next_offset: ptr = @ptr_offset(block_start, 8)
      var _w1: () = @ptr_write(next_offset, old_head)

      // Return updated GPA with this block as new head
      return GeneralPurposeAllocator {
        parent: gpa.parent,
        free_list: block_start,
        heap_start: gpa.heap_start,
        heap_end: gpa.heap_end,
      }
    }
  }

  realloc = fn(self: GeneralPurposeAllocator, ptr: ptr, new_size: u64) bool {
    // Try to expand in-place
    // For bootstrap, always return false (not supported yet)
    return false
  }

  remap = fn(self: GeneralPurposeAllocator, ptr: ptr, new_size: u64) (ptr, GeneralPurposeAllocator) {
    unsafe {
      let gpa: GeneralPurposeAllocator = self

      // Get old block size from header
      let ptr_as_int: u64 = @ptr_to_int(ptr)
      let header_size: u64 = 16
      let block_start_int: u64 = ptr_as_int - header_size
      let block_start: ptr = @int_to_ptr(block_start_int)
      let old_total_size: u64 = @ptr_read(block_start, @type(u64))
      let old_size: u64 = old_total_size - header_size

      // Allocate new block
      let alloc_result: (ptr, GeneralPurposeAllocator) = gpa.alloc(new_size)
      let new_ptr: ptr = alloc_result.0
      let gpa2: GeneralPurposeAllocator = alloc_result.1

      // Copy old data to new location
      let copy_size: u64 = if old_size < new_size { old_size } else { new_size }
      memcpy(new_ptr, ptr, copy_size)

      // Free old block
      let gpa3: GeneralPurposeAllocator = gpa2.free(ptr)

      return (new_ptr, gpa3)
    }
  }
}

// Helper functions for Arena

// Create a new arena
// parent_alloc: PageAllocator to use for backing memory
// Arena starts with zero capacity and grows on demand
fn arena_create(parent_alloc: PageAllocator) Arena {
  // Start with no buffer, will allocate on first alloc
  var null_addr: u64 = 0
  var null_ptr: ptr = unsafe { @int_to_ptr(null_addr) }

  return Arena {
    parent: parent_alloc,
    buffer: null_ptr,
    capacity: 0,
    used: 0,
    allocated_pages: 0,
  }
}

// Reset arena (free all allocations, reset used counter)
fn arena_reset(arena: Arena@4) Arena {
  return Arena {
    parent: arena.parent,
    buffer: arena.buffer,
    capacity: arena.capacity,
    used: 0,
    allocated_pages: arena.allocated_pages,
  }
}

// Destroy arena (free all memory)
fn arena_destroy(arena: Arena@?) () {
  unsafe {
    // Free the arena buffer if it was allocated
    var has_buffer: bool = arena.allocated_pages > 0
    if has_buffer {
      arena.parent.free(arena.buffer, arena.allocated_pages)
    }
    return ()
  }
}

// Helper functions for allocator creation

fn page_allocator_create() PageAllocator {
  // Standard page size is 4096 bytes (4KB)
  return PageAllocator {
    page_size: 4096,
  }
}

fn gpa_create(parent_alloc: PageAllocator) GeneralPurposeAllocator {
  var null_addr: u64 = 0
  var null_ptr: ptr = unsafe { @int_to_ptr(null_addr) }

  return GeneralPurposeAllocator {
    parent: parent_alloc,
    free_list: null_ptr,
    heap_start: null_ptr,
    heap_end: null_ptr,
  }
}
