// Vec[A, n] - Dynamic array type
// n represents initial capacity (not enforced at runtime)

type Vec[A, n: U64] = {
  data: ptr,      // Pointer to heap-allocated array
  len: U64,       // Current number of elements
  cap: U64,       // Current capacity
}

// Memory allocation functions (C stdlib)
extern "C" {
  fn malloc(size: U64) ptr;
  fn realloc(ptr: ptr, size: U64) ptr;
  fn free(ptr: ptr) ();
}

// VecOps type class for vector operations
class VecOps {
  new: fn() Vec[A, n];
  push: fn(Vec[A, n], ptr) Vec[A, n];
  pop: fn(Vec[A, n]) (ptr, Vec[A, n]);
  get: fn(Vec[A, n], U64) ptr;
  set: fn(Vec[A, n], U64, ptr) Vec[A, n];
  length: fn(Vec[A, n]) U64;
  capacity: fn(Vec[A, n]) U64;
  free: fn(Vec[A, n]) ();
}

// Instance for Vec[ptr, 8] - generic pointer vector with initial capacity 8
instance VecOps[Vec[ptr, 8]] {
  new = fn() Vec[ptr, 8] {
    unsafe {
      // Allocate initial capacity for 8 pointers
      var initial_cap: U64 = 8
      var size: U64 = initial_cap * 8  // 8 bytes per pointer
      var data: ptr = malloc(size)

      return Vec[ptr, 8] {
        data: data,
        len: 0,
        cap: initial_cap,
      }
    }
  }

  push = fn(self: Vec[ptr, 8], elem: ptr) Vec[ptr, 8] {
    unsafe {
      var v: Vec[ptr, 8] = self

      // Check if we need to grow
      var needs_grow: Bool = v.len >= v.cap

      v = if needs_grow {
        {
          // Double the capacity
          var new_cap: U64 = v.cap * 2
          var new_size: U64 = new_cap * 8
          var new_data: ptr = realloc(v.data, new_size)

          Vec[ptr, 8] {
            data: new_data,
            len: v.len,
            cap: new_cap,
          }
        }
      } else {
        v
      }

      // Write element at end
      var offset: U64 = v.len
      var elem_ptr: ptr = @ptr_offset(v.data, offset)
      @ptr_write(elem_ptr, elem)

      return Vec[ptr, 8] {
        data: v.data,
        len: v.len + 1,
        cap: v.cap,
      }
    }
  }

  pop = fn(self: Vec[ptr, 8]) (ptr, Vec[ptr, 8]) {
    unsafe {
      var v: Vec[ptr, 8] = self

      // Check if empty
      var is_empty: Bool = v.len == 0

      var result: ptr = if is_empty {
        // Return null pointer if empty
        @ptr_offset(v.data, 0)  // Just return data ptr as null indicator
      } else {
        {
          // Get last element
          var last_idx: U64 = v.len - 1
          var elem_ptr: ptr = @ptr_offset(v.data, last_idx)
          @ptr_read(elem_ptr, @type(ptr))
        }
      }

      var zero: U64 = 0
      var new_len: U64 = if is_empty { zero } else { v.len - 1 }

      var new_v: Vec[ptr, 8] = Vec[ptr, 8] {
        data: v.data,
        len: new_len,
        cap: v.cap,
      }

      return (result, new_v)
    }
  }

  get = fn(self: Vec[ptr, 8], index: U64) ptr {
    unsafe {
      var v: Vec[ptr, 8] = self

      // Bounds check (return null if out of bounds)
      var in_bounds: Bool = index < v.len

      var null_ptr: ptr = @ptr_offset(v.data, 0)
      var result: ptr = if in_bounds {
        {
          var elem_ptr: ptr = @ptr_offset(v.data, index)
          @ptr_read(elem_ptr, @type(ptr))
        }
      } else {
        null_ptr
      }

      return result
    }
  }

  set = fn(self: Vec[ptr, 8], index: U64, elem: ptr) Vec[ptr, 8] {
    unsafe {
      var v: Vec[ptr, 8] = self
      var in_bounds: Bool = index < v.len

      var elem_ptr: ptr = @ptr_offset(v.data, index)
      var should_write: Bool = in_bounds

      if should_write {
        @ptr_write(elem_ptr, elem)
      } else {
        ()
      }

      return v
    }
  }

  length = fn(self: Vec[ptr, 8]) U64 {
    var v: Vec[ptr, 8] = self
    return v.len
  }

  capacity = fn(self: Vec[ptr, 8]) U64 {
    var v: Vec[ptr, 8] = self
    return v.cap
  }

  free = fn(self: Vec[ptr, 8]) () {
    unsafe {
      var v: Vec[ptr, 8] = self
      free(v.data)
      return ()
    }
  }
}
