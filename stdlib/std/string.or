// StringLike type class for types that can be constructed from strings
// Used by bidirectional type checking for automatic string literal conversion
// Example: let r: Rope = "hello" desugars to Rope.from_str("hello")
class StringLike {
  from_str: fn(str) Self;
}

import std.alloc
import std.mem

// String type class for string operations
class String {
  len: fn(str) i64;
  at: fn(str, i64) u8;
  slice: fn(str, i64, i64, Arena) (str, Arena);
  is_empty: fn(str) bool;
  equals: fn(str, str) bool;
  starts_with: fn(str, str) bool;
  ends_with: fn(str, str) bool;
  find: fn(str, str) i64;
  contains: fn(str, str) bool;
  char_at: fn(str, i64) u8;
}

// String instance implementation for primitive str type
instance String[str] {
  len = fn(self: str) i64 {
    unsafe {
      var length: i64 = 0
      var p: ptr = self
      while @ptr_read(p, @type(u8)) != 0 {
        length = length + 1
        p = @ptr_offset(p, 1)
      }
      return length
    }
  }

  at = fn(self: str, index: i64) u8 {
    unsafe {
      var p: ptr = self
      p = @ptr_offset(p, index)
      return @ptr_read(p, @type(u8))
    }
  }

  slice = fn(self: str, start: i64, end: i64, arena: Arena) (str, Arena) {
    unsafe {
      // Calculate slice length
      let slice_len: i64 = end - start

      // Handle empty or invalid slice
      let is_invalid: bool = slice_len <= 0

      return if is_invalid {
        ("", arena)
      } else {
        // Convert i64 to u64 for allocation
        let len_ptr: ptr = @int_to_ptr(slice_len)
        let len_u64: u64 = @ptr_to_int(len_ptr)
        let alloc_size: u64 = len_u64 + 1  // +1 for null terminator

        // Allocate buffer
        let alloc_result: (ptr, Arena) = arena.alloc(alloc_size)
        let buffer: ptr = alloc_result.0
        let arena2: Arena = alloc_result.1

        // Copy slice data
        let src: ptr = @ptr_offset(self, start)
        let _: () = memcpy(buffer, src, len_u64)

        // Null-terminate
        let null_pos: ptr = @ptr_offset(buffer, len_u64)
        let zero: u8 = 0
        let _: () = @ptr_write(null_pos, zero)

        (buffer, arena2)
      }
    }
  }

  is_empty = fn(self: str) bool {
    unsafe {
      var p: ptr = self
      var first: u8 = @ptr_read(p, @type(u8))
      return first == 0
    }
  }

  equals = fn(self: str, other: str) bool {
    unsafe {
      var p1: ptr = self
      var p2: ptr = other
      var continue: bool = true
      var result: bool = true

      while continue {
        var c1: u8 = @ptr_read(p1, @type(u8))
        var c2: u8 = @ptr_read(p2, @type(u8))

        result = if c1 != c2 { false } elseif c1 == 0 { true } else { true }
        continue = if c1 != c2 { false } elseif c1 == 0 { false } else { true }

        p1 = @ptr_offset(p1, 1)
        p2 = @ptr_offset(p2, 1)
      }

      return result
    }
  }

  starts_with = fn(self: str, prefix: str) bool {
    unsafe {
      var p_str: ptr = self
      var p_prefix: ptr = prefix
      var result: bool = true
      var continue: bool = true

      while continue {
        var prefix_char: u8 = @ptr_read(p_prefix, @type(u8))
        continue = if prefix_char != 0 { true } else { false }

        var c_str: u8 = if continue { @ptr_read(p_str, @type(u8)) } else { 0 }
        var c_prefix: u8 = if continue { @ptr_read(p_prefix, @type(u8)) } else { 0 }

        result = if continue {
          if c_str != c_prefix { false } else { true }
        } else { result }

        continue = if result { continue } else { false }

        p_str = @ptr_offset(p_str, 1)
        p_prefix = @ptr_offset(p_prefix, 1)
      }

      return result
    }
  }

  ends_with = fn(self: str, suffix: str) bool {
    // Need len() to implement this - call recursively
    var self_len: i64 = self.len()
    var suffix_len: i64 = suffix.len()

    var result: bool = if suffix_len > self_len { false } else { true }

    result = if result {
      unsafe {
        var start_pos: i64 = self_len - suffix_len
        var p_str: ptr = self
        p_str = @ptr_offset(p_str, start_pos)

        var p_suffix: ptr = suffix
        var continue: bool = true
        var is_match: bool = true

        while continue {
          var suffix_char: u8 = @ptr_read(p_suffix, @type(u8))
          continue = if suffix_char != 0 { true } else { false }

          var c_str: u8 = if continue { @ptr_read(p_str, @type(u8)) } else { 0 }
          var c_suffix: u8 = if continue { @ptr_read(p_suffix, @type(u8)) } else { 0 }

          is_match = if continue {
            if c_str != c_suffix { false } else { true }
          } else { is_match }

          continue = if is_match { continue } else { false }

          p_str = @ptr_offset(p_str, 1)
          p_suffix = @ptr_offset(p_suffix, 1)
        }

        is_match
      }
    } else { false }

    return result
  }

  find = fn(self: str, needle: str) i64 {
    unsafe {
      var p_haystack: ptr = self
      var pos: i64 = 0
      var found: bool = false
      var result: i64 = -1
      var continue: bool = true
      var p_check: ptr = self
      var p_needle: ptr = needle
      var matches: bool = true
      var inner_continue: bool = true

      while continue {
        var haystack_char: u8 = @ptr_read(p_haystack, @type(u8))
        continue = if haystack_char != 0 { true } else { false }

        p_check = if continue { p_haystack } else { p_check }
        p_needle = if continue { needle } else { p_needle }
        matches = if continue { true } else { matches }
        inner_continue = if continue { true } else { inner_continue }

        while inner_continue {
          var needle_char: u8 = @ptr_read(p_needle, @type(u8))
          inner_continue = if needle_char != 0 { true } else { false }

          var c_check: u8 = if inner_continue { @ptr_read(p_check, @type(u8)) } else { 0 }
          var c_needle: u8 = if inner_continue { @ptr_read(p_needle, @type(u8)) } else { 0 }

          matches = if inner_continue {
            if c_check != c_needle { false } else { matches }
          } else { matches }

          p_check = @ptr_offset(p_check, 1)
          p_needle = @ptr_offset(p_needle, 1)
        }

        found = if continue { matches } else { found }
        result = if found { pos } else { result }
        continue = if found { false } else { continue }

        p_haystack = @ptr_offset(p_haystack, 1)
        pos = pos + 1
      }

      return result
    }
  }

  contains = fn(self: str, needle: str) bool {
    let pos: i64 = self.find(needle)
    return pos >= 0
  }

  char_at = fn(self: str, index: i64) u8 {
    return self.at(index)
  }
}
